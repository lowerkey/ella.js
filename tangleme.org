* INPROGRESS ella.js
  SCHEDULED: <2013-10-24 Thu>
Aims to provide a call graph of javascript functions by the end of next week. 

** INPROGRESS Todos
- Get pegjs to build the supplied example javascript grammar.
- Read pegjs output, comparing it to DebugVisitor of last project.
- Integrate ubigraph.js
- Build graphs
  - definitions
  - calls

** DONE Getting The JavaScript Grammar
   CLOSED: [2013-10-20 Sun 00:24]
#+BEGIN_SRC javascript
  #!/usr/bin/env node

  // ella.js
  // Joshua Moore
  // 2013-10-19
  
  // Utility Functions
  
  // path 2 string
  var p2s = function(path){
      var buf = fs.readFileSync(path);
      return buf.toString('utf-8');
  }
  
  // Build the parser
  var fs = require('fs');
  var PEG = require('pegjs');
  var javascript_grammar_path = '../node_modules/pegjs/examples/javascript.pegjs';
  var javascript_grammar_buffer = fs.readFileSync(javascript_grammar_path);
  var javascript_grammar_string = javascript_grammar_buffer.toString('utf-8')
  var javascript_parser = PEG.buildParser(javascript_grammar_string);
  
  // Parse the file described in arguments
  process.argv.slice(2).forEach(function(val, index, array){
      console.dir(javascript_parser.parse(p2s(val)));
  });

#+END_SRC

*** Thanks
- http://nodejs.org/api/fs.html
- https://github.com/dmajda/pegjs

** INPROGRESS Interpreting The Javascript Grammar
*** Visitors
Now I get to implement my own Visitor, in javascript, yay!
http://stackoverflow.com/questions/9831415/how-to-implement-visitor-pattern-in-javascript/14462086#14462086
Or not. 

*** ===
Seeing how the tree is already labeled in JSON for me, all I really have to 
do is walk the tree. 

#+BEGIN_SRC javascript :tangle WalkPEG.js
  
  module.exports = {
      PegWalker: function(type_callbacks, init){
          this.type_callbacks = type_callbacks || {};
          if(typeof(init) == 'function'){
              init.call(this);
          }
  
          var that = this;
          this.walk = function(tree, context){
              var callback = that.type_callbacks[tree.type];
              if(callback){
                  var local_context = {
                      parent: context
                  };
                  callback.call(that, tree, local_context);
              }else{
                  console.log('PegWalker:', 'Encountered unhandled node type:', tree.type);
              }
          };
      }          
  };
  
#+END_SRC

This should provide a skeleton implementation. Please note that to use it,you 
will have to inspect the parser nodes, supply functions that can react to 
each of the `element` types to the PegWalker, calling walk again on each of
the child nodes.
 
*** INPROGRESS Reacting to the parser
#+BEGIN_SRC javascript :tangle ella.js  
  // ella.js
  // Joshua Moore
  // 2013-10-19
  
  /* Imports */
  var fs = require('fs');
  var PegWalker = require('./WalkPEG.js').PegWalker;
  
  /* Utility Functions */
  
  // path 2 string
  var p2s = function(path){
      var buf = fs.readFileSync(path);
      return buf.toString('utf-8');
  }
  
  /* Building the Parser */
  console.log('loading parser...');
  var js_grammar_path = '../node_modules/pegjs/examples/javascript.pegjs';
  var js_grammar_buffer = fs.readFileSync(js_grammar_path);
  var js_grammar_string = js_grammar_buffer.toString('utf-8')
  var js_parser = require('./js_parser.js'); 
  
  /* Parse the file described in arguments */
  console.log('loading ubigraph...');
  var u = require('../node-ubigraph/ubigraph.js');
  var ubigraph = new u.Ubigraph();
  ubigraph.clear();
  var noop = function(){};
  var error = function(err){
      console.log(err);
  };
  var label_vertex = function(id, label){
      ubigraph.setVertexAttribute(id, 'label', label, noop);
  };
  
  var edgeFromParent = function(context){
      var child = context;
      var parent = child.parent;
      while(!(parent.hasOwnProperty('vid')) && parent.hasOwnProperty('parent')){
          parent = parent.parent;
      }
      ubigraph.newEdge(parent.vid, child.vid, function(err, id){
          ubigraph.setEdgeAttribute(id, 'oriented', 'true');
      });
  };
  
  console.log('setting up walker');
  var walker = new PegWalker({
        'Program': function(node, context){
            var that = this;
            ubigraph.newVertex(function(err, id){
                if(!err){
                    if(typeof(id) != 'number'){
                        console.log("Something's fishy in Program");
                    }
    
                    label_vertex(id, 'Program');
  
                    context.vid = id;
                    for(var i=0; i<node['elements'].length; i++){
                        that.walk(node.elements[i], context);
                    }
                }
            });
        },
        'VariableStatement': function(node, context){
            var visitor = this;
            var that = this;
            ubigraph.newVertex(function(err, vid){
                if(!err){  
                    var local_context = {
                        parent: context,
                        vid: vid
                    };
                    edgeFromParent(local_context);
                    for(var i=0; i<node.declarations.length; i++){
                        visitor.walk(node.declarations[i], local_context);
                    }
                }
            });
        },
        'AssignmentExpression': function(node){
            // console.log(node.type, node.left, '=', node.right);
        },
        'FunctionCall': function(node, context){
            ubigraph.newVertex(function(err, vid){
                ubigraph.setVertexAttribute(vid, 'label');
                local_context = {
                    parent: context,
                    vid: vid
                }
                edgeFromParent(local_context);
            });
        }
    }, function(){
        this.vertices = [];
    });
    
    process.argv.slice(2).forEach(function(val, index, array){
        console.log('parsing', val);
        var ast = js_parser.parse(p2s(val));
    
        console.dir(ast);
    
        console.log('traversing', val);
        walker.walk(ast, {});
    });
    
#+END_SRC
